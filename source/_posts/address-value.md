---
title: Python的传值和传地址
date: 2020-07-18 13:52:51
tags: [python]
---

# Python的传值和传地址

## C/C++中的传值和传地址

​	这个话题在学习C与C++的时候是一个被反复提及的问题，具体含义不再赘述。

​	在C中，我们可以给函数传值（也称为形参），也可以给函数传变量的内存地址（也称为实参）；

​	C++在C的基础上增加了函数传引用的操作，例如：

```C++
void func(int &a){
	a=1;
}
int main(){
	int a=2;
	func(a);
	cout<<a<<endl;//输出2
	return 0;
}
```

​	在变量名的前面加一个`&`符号，表示这是一个引用，在函数内对`a`的任何修改都是对内存地址中的值进行直接操作。



## Python中的传值和传引用

​	Python传值/引用的机制与C有所不同，因为**Python不允许程序员选择采用传值还是传址**，它采用的是“传对象引用”的方式，实际上，**这种方式相当于传值和传址的综合**。

​	Python将对象大致划分为两类：一类被称为“可变对象”，另一类是“不可变对象”

- 可变对象：列表、字典、**用户类**

- 不可变对象：数字、字符串、元组

​	例如，以下程序的输出结果就为`2`，显然`func(a)`中的参数`a`属于值传递，因为`a`是数字，是一个不可变对象。

```python
def func(a):
	a=1

if __name__=="__main__":
	a=2
	func(a)
	print(a)	#输出2
```



​	相对的，当`a`是一个可变对象时（本例中为`list`），`a`中的值发生了改变。

```python
def func(a):
	a[0]=1

if __name__=="__main__":
	a=[9,8,7]
	func(a)
	print(a) #输出[1,8,7]
```



​	其中要特别说明的是，用户定义的类也是一个可变对象

```python
class tt():
    def __init__(self):
        self.a=1	#初始化为1

def func(obj):
    obj.a=2

if __name__=="__main__":
    obj=tt()	#实例化类tt
    func(obj)
    print(obj.a)	#输出2
```



## 赋值与拷贝

​	Python中的赋值与C/C++中的赋值有着细微的差别，这点我曾吃过亏。

​	举一个例子：

```c++
void func(){
	int a=1;
	int b;
	b=a;
	printf("%d %d\n",a,b);// a,b都等于1
    a=2;
    printf("%d %d\n",a,b);// a=2,b=1
}
```

​	`	a`和`b`在内存中的地址是不一样的，它们存储的值一样，所以对`a`做修改并不会影响`b`的值。



​	而在Python中就不一样了：

```python
def func():
	a=1
	b=a
	print(a,b) # 1 1
	b=2
	print(a,b) # 2 2
```

​	当我们对`b`的值进行修改后，我们发现，`a`的值“竟然”也跟着改变了。

​	其实，这是因为在Python中`b=a`这个操作相当于申请了一个标签`b`，将它指向标签`a`所对应的内存地址。而并不是将`a`中的值"拷贝"一份，再赋值给`b`。



## 内置函数id

​	python中有一个内置函数`id`，它可以用来查看一个变量在内存中的地址，借此我们可以检测使用的对象是否是同一个。

```python
a = 100
b = 200 
print(id(a))
print(id(b))
c = a
print(id(c))
print(a is c)	#c和a所指向的是同一个内存地址
a += 300	#当a的值发生改变，会单独为a重新分配一个内存
print(a)
print(c)
print(a is c)
print(id(a))
print(id(c))
```

​	输出：

```
1549495552
1549498752
1549495552
True
400
100
False
93638128
1549495552
```



## 浅拷贝与深拷贝

​	如果我们要实现"拷贝"这一操作，也就是我们想要新建一个与`a`值相等的`b`变量（而且它们所指向的内存地址不同），那就要使用到Python中的`copy`库。

```python
import copy

a=[1,2,3]
b=a
a.append(4)
print a,b

a=[1,2,3]
b=copy.copy(a)	#浅拷贝
a.append(4)
print a,b
```

```
[1, 2, 3, 4] [1, 2, 3, 4]
[1, 2, 3, 4] [1, 2, 3]
```

​	上面代码中的`copy.copy`又被称为“浅拷贝“。

​	那么深拷贝又是什么呢？

​	实际上浅拷贝依然可能会导致被拷贝对象和生成对象之间产生联系，比如说：

```python
a=[1,[1,2],3]
b=copy.copy(a)
a[1].append(4)
print a,b
```

```
[1, [1, 2, 4], 3] [1, [1, 2, 4], 3]
```

​	这很显然是不对的。为什么会导致这样的情况呢？

​	这是因为在浅拷贝时，拷贝出来的新对象的地址和原对象是不一样的，但是**新对象里面的可变元素（如列表）的地址和原对象里的可变元素的地址是相同的**，也就是说浅拷贝拷贝的是浅层次的数据结构（不可变元素），**对象里的可变元素作为深层次的数据结构并没有被拷贝到新地址里面去**，而是和原对象里的可变元素指向同一个地址，所以在新对象或原对象里对这个可变元素做修改时，两个对象是同时改变的，但是深拷贝不会这样，这个是浅拷贝相对于深拷贝最根本的区别。

​	对于C++熟悉的同学就知道，如果要拷贝的类中有指针类型，那就必须根据这个指针所指向的内容重新申请一块空间，然后将原指针所指向的内容复制到新的空间内。

​	所以在这种情况下，我们要采用深拷贝`copy.deepcopy()`

```python
a=[1,[1,2],3]
b=copy.deepcopy(a)
a[1].append(4)
print a,b
```

```
[1, [1, 2, 4], 3] [1, [1, 2], 3]
```

​	换言之，`deepcopy`产生的新对象和原来的对象就完全没有关系了。而`copy`在可变元素套可变元素（`list`套`list`，`dict`套`list`等等）的情况下，仍然有可能会出现相互影响的情况。